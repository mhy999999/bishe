# 计算机组成原理复习提纲（按考点）

## 1. 码制转换

### 1.1 常见码制
- 二进制：基数 2（0/1）
- 八进制：基数 8（0~7）
- 十六进制：基数 16（0~9，A~F）
- 十进制：基数 10（0~9）

### 1.2 进制转换方法
#### 1) 二进制 ↔ 八/十六进制（最快）
- 二进制 → 八进制：从小数点向两侧每 3 位分组，不足补 0
- 二进制 → 十六进制：从小数点向两侧每 4 位分组，不足补 0
- 八/十六进制 → 二进制：每一位直接展开成 3/4 位二进制

例：  
- 1101011₂ = 1 101 011₂ = 153₈  
- 1101011₂ = 0110 1011₂ = 6B₁₆

#### 2) 十进制整数 → r 进制（除基取余）
- 不断 “除以 r 取余”，余数倒序排列

例：13₁₀ → 二进制  
13/2=6 余1  
6/2=3 余0  
3/2=1 余1  
1/2=0 余1  
=> 1101₂

#### 3) 十进制小数 → r 进制（乘基取整）
- 不断 “乘以 r 取整数部分”，整数部分顺序排列（可能循环）

例：0.625₁₀ → 二进制  
0.625×2=1.25 取1  
0.25×2=0.5 取0  
0.5×2=1.0 取1  
=> 0.101₂

#### 4) r 进制 → 十进制（按位权展开）
- 整数部分：从低位到高位按 r^k
- 小数部分：按 r^-k

例：101.01₂ = 1·2² + 0·2¹ + 1·2⁰ + 0·2⁻¹ + 1·2⁻² = 5.25₁₀

---

## 2. 码制数值表示范围（定点为主）

设字长为 n 位。

### 2.1 无符号数（Unsigned）
- 范围：0 ～ 2^n - 1

### 2.2 有符号数常见编码
#### 1) 原码（Sign-Magnitude）
- 最高位符号位：0 正，1 负；其余表示绝对值
- 范围：-(2^(n-1)-1) ～ +(2^(n-1)-1)
- 特点：+0 与 -0 两个零，运算不方便

#### 2) 反码（Ones’ Complement）
- 正数不变；负数为正数按位取反
- 范围同原码，仍有 +0 与 -0

#### 3) 补码（Two’s Complement，最常用）
- 正数不变；负数 = 反码 + 1
- 范围：-2^(n-1) ～ + (2^(n-1)-1)
- 特点：只有一个 0；加减运算统一用加法器完成

### 2.3 补码快速结论
- 最小负数：1000...0₂（值 = -2^(n-1)）
- 最大正数：0111...1₂（值 = 2^(n-1)-1）
- 判断溢出（有符号）：同号相加得异号，或异号相减得同号

---

## 3. 冯诺依曼架构（Von Neumann）

### 3.1 核心思想
- 存储程序：指令和数据统一存放在主存中，形式上都以二进制编码表示
- 按地址访问：CPU通过地址访问存储器单元，取出指令/数据
- 典型五大部件：运算器、控制器、存储器、输入、输出
- 瓶颈：CPU 与存储器之间带宽/延迟限制（冯诺依曼瓶颈）

### 3.2 CPU“根据地址找指令”的流程（关键寄存器）
- PC（程序计数器）：保存下一条指令地址
- MAR（存储器地址寄存器）：送往存储器的地址
- MDR（存储器数据寄存器）：与存储器交换数据
- IR（指令寄存器）：保存当前正在译码/执行的指令

---

## 4. 指令格式、执行顺序与跳转

### 4.1 指令基本格式：OP + 地址（或其他字段）
- OP（操作码）：决定做什么操作（加/减/访存/跳转等）
- 地址字段：可能是
  - 操作数地址
  - 立即数
  - 寄存器编号
  - 跳转目标/偏移等

### 4.2 指令执行两类控制流
- 顺序执行：PC = PC + 指令字长（或 PC+4 等）
- 转移/跳转：由跳转指令修改 PC
  - 条件转移：根据标志位或比较结果决定是否改 PC
  - 无条件跳转：直接改 PC

### 4.3 指令周期（宏观）
- 取指（Fetch）→ 译码（Decode）→ 执行（Execute）→ 访存（如需）→ 写回（如需）

---

## 5. 定点数与浮点数

### 5.1 定点数（Fixed-Point）
- 小数点位置约定固定（常见：纯整数或 Q 格式）
- 优点：硬件简单、速度快、可控性强
- 缺点：动态范围有限，容易溢出

### 5.2 浮点数（Floating-Point）基本结构
- 符号位 S：决定正负
- 指数 E：决定数量级（范围/大小）
- 尾数/小数 F（有效数）：决定精度

通用形式（IEEE 754）：  
值 = (-1)^S × (1.F) × 2^(E - Bias)（规格化数）

---

## 6. IEEE 754 浮点数：位数、范围与换算

### 6.1 单精度（32-bit float）
- S：1 位
- E：8 位，Bias = 127
- F：23 位
- 规格化：E ∈ [1, 254]（0 和 255 用于特殊数）

典型特点：
- 有效精度约 24 位二进制（含隐藏的最高位 1），约 7 位十进制有效数字

### 6.2 双精度（64-bit double）
- S：1 位
- E：11 位，Bias = 1023
- F：52 位

典型特点：
- 有效精度约 53 位二进制，约 15~16 位十进制有效数字

### 6.3 特殊值（单/双精度规则一致）
- E=0, F=0：±0
- E=0, F≠0：非规格化数（denormal/subnormal），用于“渐进下溢”
- E=全1, F=0：±∞
- E=全1, F≠0：NaN（非数）

### 6.4 十进制 → IEEE 754（常考步骤）
以把十进制 x 转成单精度为例：
1) 确定符号位 S
2) 把 |x| 转成二进制
3) 规格化成 1.xxx × 2^k，得到 k
4) 指数域 E = k + Bias（Bias=127）
5) 尾数域 F = 小数点后 xxx… 截断/舍入到 23 位
6) 处理可能的溢出/下溢/舍入

例：-13.25  
- S=1  
- 13.25₁₀ = 1101.01₂  
- 规格化：1.10101₂ × 2^3 → k=3  
- E = 3+127=130 = 10000010₂  
- F = 10101 后补 0 到 23 位  
- 最终：1 | 10000010 | 10101000000000000000000

---

## 7. 标志位、溢出位：定点与浮点运算要点

### 7.1 常见标志位（不同体系结构命名略有差异）
- Z（Zero）：结果是否为 0
- N/S（Negative/Sign）：结果最高位（符号）
- C/CF（Carry）：无符号进位/借位（常用于无符号溢出判断）
- V/OF（Overflow）：有符号溢出（补码意义下）

### 7.2 定点加法溢出（补码）
- 有符号溢出判定：
  - 两个操作数同号，结果异号 ⇒ OF=1
- 无符号溢出判定：
  - 最高位产生进位 ⇒ CF=1

例（4 位补码）：
- 0111(+7) + 0001(+1) = 1000(-8) ⇒ 同号加出异号，有符号溢出（OF=1）

### 7.3 浮点运算关注点
- 对阶：指数对齐，尾数右移（可能损失低位精度）
- 规格化：运算后重新调整为 1.F × 2^k
- 舍入：常见“就近舍入到偶数”（round to nearest, ties to even）
- 异常：溢出、下溢、无效操作、除零、不精确

---

## 8. 计算机中“所有周期”概念（常考名词区分）

- 时钟周期（Clock Cycle）：CPU时钟的基本节拍，最小时间单位之一
- CPU周期/机器周期（Machine Cycle）：完成一个基本操作所需的周期集合（不同教材定义略有差异）
- 指令周期（Instruction Cycle）：完成一条指令所需的全部过程（取指、译码、执行等）
- 存储器周期（Memory Cycle）：主存完成一次读或写所需时间（含访问与恢复）
- 总线周期（Bus Cycle）：一次总线事务（如一次读/写传输）所需时间
- 访存时间（Memory Access Time）：发出地址到数据稳定的延迟（常用于算AMAT）

记忆关系（常见理解）：  
指令周期 ≥（若干）机器周期 ≥（若干）时钟周期

---

## 9. 奇偶校验（Parity）

### 9.1 定义
- 在数据后加 1 位校验位，使“1 的个数”满足某种奇/偶性
  - 偶校验：总 1 的个数为偶数
  - 奇校验：总 1 的个数为奇数

### 9.2 能力
- 能检测：所有“奇数位翻转”错误（尤其是 1 位错误）
- 不能可靠检测：偶数位翻转（例如两位同时翻转）

例（偶校验）：
- 数据 1011001（1 的个数=4，为偶）→ 校验位=0
- 数据 1011001 + 校验位 0，使总 1 数仍为偶

---

## 10. 精简指令集（RISC）与复杂指令集（CISC）

### 10.1 RISC（典型：MIPS、ARM早期风格）
- 指令较少、格式规整、固定长度较常见
- 以“Load/Store”为核心：运算多在寄存器之间
- 更利于流水线、译码简单、时钟频率更高

### 10.2 CISC（典型：x86）
- 指令多且复杂，支持更丰富寻址方式
- 指令长度可变更常见
- 复杂指令可能分解为内部微操作执行

考试常问对比点：指令长度、寻址方式、流水线友好程度、编译器依赖、硬件复杂度。

---

## 11. CPU访问存储器的平均访问时间（AMAT）

### 11.1 单级Cache（最常用公式）
- AMAT = 命中时间 HitTime + 未命中率 MissRate × 未命中代价 MissPenalty

例：HitTime=1ns，MissRate=5%，MissPenalty=50ns  
AMAT = 1 + 0.05×50 = 3.5ns

### 11.2 多级Cache（思路）
- 把下一级的AMAT当作上一级的MissPenalty递归展开
- 关键仍是：每级的命中时间、未命中率、向下访问代价

---

## 12. CPU结构部件：有哪些、算哪一类

### 12.1 常见部件列表
- 运算器：ALU、移位器等
- 控制器：控制单元（硬布线/微程序控制），负责产生控制信号
- 寄存器组：通用寄存器、PC、IR、PSW/标志寄存器等
- 总线接口/数据通路：内部总线、多路复用器等（视教材划分）
- （现代CPU还会集成）多级Cache、分支预测、流水线部件等

### 12.2 常见分类方式
- 数据通路（Datapath）：寄存器、ALU、移位器、多路器、内部总线
- 控制通路（Control）：控制单元、时序控制逻辑、控制信号生成

---

## 13. CPU 到辅存：中间“有多少层/种”（存储层次）

常见存储层次（从快到慢、从小到大）：
1) 寄存器（CPU内部）
2) Cache（L1/L2/L3）
3) 主存（DRAM）
4) 辅存（SSD/HDD）
（更外层还可扩展：网络存储/云存储、磁带等）

也可从“路径”理解：CPU ↔ Cache ↔ 主存 ↔ I/O系统（控制器/总线）↔ 辅存。

---

## 14. 主存（块）与 Cache（行）映射方式（重点）

设：Cache按“行/块（Line）”存储，主存按“块（Block）”划分，块大小通常与行大小一致。

### 14.1 直接映射（Direct-Mapped）
- 主存块号 b 只能映射到 Cache 行号：i = b mod (Cache行数)
- 地址划分：Tag | Index | BlockOffset
- 优点：硬件简单、命中快
- 缺点：冲突未命中多（不同块争同一行）

### 14.2 全相联映射（Fully Associative）
- 任意主存块可放到任意Cache行
- 地址划分：Tag | BlockOffset（无Index）
- 优点：冲突最少
- 缺点：比较器多、硬件复杂、命中判定较慢

### 14.3 组相联映射（Set-Associative）
- Cache分成若干组，每组 k 路（k-way）
- 主存块号 b 映射到组号：set = b mod (组数)，再放入该组任意一路
- 地址划分：Tag | SetIndex | BlockOffset
- 折中：速度/成本/冲突率综合较好

---

## 15. 替换算法原理（Cache/块替换常考）

当组相联/全相联发生未命中且目标组已满，需要选择一行替换：
- LRU（最近最少使用）：替换最长时间没被访问的行（效果好，硬件实现相对复杂）
- FIFO：替换最早进入的行（简单，效果一般）
- Random：随机替换（简单，统计上可接受）
- LFU：最不常用（需计数，硬件更复杂）

原则：替换策略影响“未命中率”，从而影响 AMAT。

---

## 16. MAR 与 MDR（必背）

- MAR（Memory Address Register，存储器地址寄存器）
  - 保存“要访问的主存地址”
  - 宽度通常等于地址总线宽度

- MDR（Memory Data Register，存储器数据寄存器）
  - 保存“从主存读出的数据/要写入主存的数据”
  - 宽度通常等于数据总线宽度（或字长）

典型取指：PC → MAR；主存读 → MDR；MDR → IR。

---

## 17. 主存扩展及其与CPU连接（3.3.4 常见考法）

### 17.1 扩展的两种基本方向
- 容量扩展（地址空间扩展）：增加存储字的数量（更深）
- 位宽扩展（数据宽度扩展）：把多个存储器芯片并联，扩大一次读写的数据位数（更宽）

### 17.2 与CPU连接的关键点
- 地址线：CPU地址总线连接到各存储芯片的地址引脚（可能部分用于片内寻址）
- 数据线：CPU数据总线连接到芯片数据引脚（位宽扩展时多片并联到不同位）
- 控制线：读/写控制信号（RD/WR 或 OE/WE）
- 片选信号（CS）：地址译码产生，决定“哪个芯片响应”
- 地址译码
  - 全译码：每个地址只选中唯一芯片（冲突少，硬件较多）
  - 部分译码：译码简化但可能出现地址镜像（同一存储体被多个地址映射）

---

## 18. MIPS 指令格式：R/I/J 型与寄存器角色（常考 20 分点）

### 18.1 R 型（Register）
字段：op | rs | rt | rd | shamt | funct  
- rs：源寄存器 1（source）
- rt：源寄存器 2（source）
- rd：目的寄存器（destination）
- 例：add rd, rs, rt  表示 rd = rs + rt

### 18.2 I 型（Immediate / Load-Store / Branch）
字段：op | rs | rt | immediate  
常见用法不同，rs/rt 角色会变：
- 立即数运算：addi rt, rs, imm  
  - rs 源，rt 目的
- 访存（Load）：lw rt, offset(rs)  
  - rs 基址（源），rt 目的
- 访存（Store）：sw rt, offset(rs)  
  - rs 基址（源），rt 是要存的源数据（source）
- 分支：beq rs, rt, offset  
  - rs/rt 都是源，用于比较；目标地址由 PC 相对偏移形成

### 18.3 J 型（Jump）
字段：op | target  
- 不显式指定通用寄存器作为源/目的
- 例：j target（直接修改 PC）
- jal 会把返回地址写入 $ra（这是语义效果，不在字段里显示目的寄存器编号）

---

## 19. 小结速背（考前一分钟版）
- 补码范围：[-2^(n-1), 2^(n-1)-1]；无符号：[0, 2^n-1]
- 单精度：1/8/23，Bias=127；双精度：1/11/52，Bias=1023
- AMAT=HitTime+MissRate×MissPenalty
- 映射：直映射 / 全相联 / 组相联；替换：LRU/FIFO/Random
- 取指链路：PC→MAR→(Mem)→MDR→IR；MAR管地址，MDR管数据
- MIPS：R型 rs/rt 源、rd 目的；I型视指令而定；J型给目标字段